2017/2/21

Notes:
JVM developers (and even some tools) often refer to the compilers by the names C1
(compiler 1, client compiler) and C2 (compiler 2, server compiler).

The primary difference between the two compilers is their aggressiveness in compiling
code. The client compiler begins compiling sooner than the server compiler does. This
means that during the beginning of code execution, the client compiler will be faster,
because it will have compiled correspondingly more code than the server compiler.

The engineering trade-off here is the knowledge the server compiler gains while it waits:
that knowledge allows the server compiler to make better optimizations in the compiled
code. Ultimately, code produced by the server compiler will be faster than that produced
by the client compiler. From a user’s perspective, the benefit to that trade-off is based
on how long the program will run, and how important the startup time of the program
is.

The obvious question here is why there needs to be a choice at all: couldn’t the JVM
start with the client compiler, and then use the server compiler as code gets hotter? That
technique is known as tiered compilation. With tiered compilation, code is first compiled
by the client compiler; as it becomes hot, it is recompiled by the server compiler.

To use tiered compilation, specify
the server compiler (either with -server or by ensuring it is the default for the particular
Java installation being used), and ensure that the Java command line includes the flag
-XX:+TieredCompilation (the default value of which is false). In Java 8, tiered compilation
is enabled by default.

The client compiler is most often used when fast startup is the primary objective.

1. The client compiler is most useful when the startup of an application
is the overriding performance concern.
2. Tiered compilation can achieve startup times very close to those
obtained from the client compiler.

It is also interesting that tiered compilation is always slightly better than the standard
server compiler. In theory, once the program has run enough to compile all the hot
spots, the server compiler might be expected to achieve the best (or at least equal) performance.
But in any application, there will almost always be some small section of code
that is infrequently executed. It is better to compile that code—even if the compilation
is not the best that might be achieved—than to execute that code in interpreted mode.

1. For jobs that run in a fixed amount of time, choose the compiler
based on which one is the fastest at executing the actual job.
2. Tiered compilation provides a reasonable default choice for batch
jobs.

For long-running applications, always choose the server compiler, preferably in conjunction with tiered compilation.

CeasarCipher:

Generally: it’s a rotation of English alphabic. E.g. if rotation is 2, the encode is start from A+2, i.e. A is at -2 of the encode array. 
And decode is start with 26-2, and “A” start at positon 2, then the increase by 1 character to constitute the array
That’s why need to “%26”, to make it loop across 26 characters

If rotation is 2:
--- encrytpion code is:[C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y, Z, A, B]
--- decrytpion code is:[Y, Z, A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X]
If rotation is 4:
--- encrytpion code is:[E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y, Z, A, B, C, D]
--- decrytpion code is:[W, X, Y, Z, A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V]


ABC:
Msg ={‘A’,’B’,’C’};
Char[] encode=’A’+(k+rotation)%26);
Char[] decode=’A’+(k-rotation+26)%26); // +26 to avoid negative

Encode={‘C’,’D’,’E’}; // rotation=3, so A+3, A+4,A+5,xxx, A+26=>3,4,5,6,xxx,0
Decode={‘M’,’N’,’O’};//as k-rotation+26 % 26, so it’s 26-3+0,26-3+1 ,xx: => 23,24,25,0,1,2,3,4,is: A+23,A+24,A+25=>‘M’,’N’,’O’. that’s rotation, rotain-1, rotaion -2 xxxx
For(int i=0;i<msg.length;i++){
	Int j=msg[i]-‘A’; // to remove the base ‘A”, so sync with the “k” in encode, 3,4,5,xxx 3+26
	Msg[i]=codes[j];
}
// encode
Int j=’A’-‘A’; //0
Msg[0]=’C’;
Msg[1]=’D’;
Msg[2]=’E’;

//decode
Int j=msg[i]-‘A’; //’C’-‘A’=3
Msg[i]=decode[j]; // correspoindg to the postion 0,-xxx, 26 in decode, 
Msg[0]=
